# Dynamic Programming

### âœ”ì£¼ì–´ì§„ ë¬¸ì œë¥¼ ì„¸ë¶„í™”í•˜ì—¬ ìµœì ì˜ í•´ë¥¼ ì°¾ëŠ” ë°©ë²• -> ë©”ëª¨ì´ì œì´ì…˜(Memoization)

#### ğŸ”†ê³§ ì¤‘ë³µëœ ë¶€ë¶„ê³¼ ë¶ˆí•„ìš”í•œ ìš”ì†Œë¥¼ ë°°ì œí•˜ëŠ” ê²ƒìœ¼ë¡œ ì—°ì‚°ì˜ íš¨ìœ¨ì„ ë†’ì¸ë‹¤.



### DPì˜ ì†ì„±

1. Overlapping Subproblem(ë¶€ë¶„ ë¬¸ì œê°€ ê²¹ì¹œë‹¤.)

2. Optimal Substructure(ìµœì  ë¶€ë¶„ êµ¬ì¡°)

   

### DP í’€ì´ ë°©ì‹

1. Top-Down

   1. í° ë¬¸ì œë¥¼ ì‘ì€ ë¬¸ì œë¡œ ë‚˜ëˆˆë‹¤.
      F(n-1), F(n-2)ë¡œ ë‚˜ëˆˆë‹¤.
   2. ì‘ì€ ë¬¸ì œë¥¼ í‘¼ë‹¤.
      F(n-1) + F(n-2)

   > ì¬ê·€í˜¸ì¶œì„ í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ í‘¼ë‹¤.

2. Bottom-up : ì‘ì€ë¬¸ì œë¥¼ í‘¼ë‹¤.

   1. ë¬¸ì œë¥¼ í¬ê¸°ê°€ ì‘ì€ ë¬¸ì œë¶€í„° ì°¨ë¡€ëŒ€ë¡œ ì“´ë‹¤.
   2. ë¬¸ì œì˜ í¬ê¸°ë¥¼ ì¡°ê¸ˆì”© í¬ê²Œ ë§Œë“¤ë©´ì„œ ë¬¸ì œë¥¼ í‘¼ë‹¤.
   3. ì‘ì€ ë¬¸ì œë¥¼ í’€ë©´ì„œ í° ë¬¸ì œì˜ ë‹µì„ êµ¬í•œë‹¤.

   ```java
   int d[100];
   public int fibonacci(int n) {
       d[0] = 0;
       d[1] = 1;
       for (int i = 2; i <= n; i++) {
           d[i] = d[i - 1] + d[i - 2];
       }
       return d[n];
   }
   ```



ì˜ˆë¥¼ ë“¤ì–´ ì„¤ëª…í•˜ëŠ” ê²ƒì´ ê°€ì¥ ì´í•´í•˜ê¸° ì‰¬ìš¸ê±°ë¼ê³  ìƒê°í•˜ì—¬ í”¼ë³´ë‚˜ì¹˜ ì•Œê³ ë¦¬ì¦˜ì„ í†µí•´ ì•Œì•„ë³´ì.

ê¸°ì¡´ í”¼ë³´ë‚˜ì¹˜ ì•Œê³ ë¦¬ì¦˜ì€, ì¬ê·€í•¨ìˆ˜ë¥¼ í†µí•´ ê³„ì‚°ì„ í•˜ê²Œ ëœë‹¤.

**f(n) = f(n-1) + f(n-2)**  -> * Overlapping Subproblem : f(n)ì„ í° ë¬¸ì œ, f(n-1), f(n-2)ì„ ì‘ì€ë¬¸ì œë¡œ ìƒê° 

â€‹                                     -> * Optimal Substructure : ì‘ì€ ë¬¸ì œë¡œ ìª¼ê°  ìš°ì¸¡í•­ì˜ f(n-1)+f(n-2)ë¡œ í°ë¬¸ì œì¸ f(n)ì˜ ê°’ì„ êµ¬í•œë‹¤.   

0 ,1 ,1, 2, 3, 5, 8 ......

| index | 0    | 1    | 2    | 3    | 4    | 5    | 6    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| value | 0    | 1    | 1    | 2    | 3    | 5    | 8    |

f(n)ì„ í†µí•´ì„œ 4ë²ˆì§¸ ì¸ë±ìŠ¤ ê°’ì„ ê°€ì ¸ì˜¤ê¸° ìœ„í•´, ì´ë¯¸ ê³„ì‚°í•œ ê°’ì„ ì¬ê·€ í˜¸ì¶œí•˜ê³  ìˆë‹¤.

f(4) = f(3) + f(2) 

f(3) = f(2) +f(1)

f(2) = ...

```java
public static int fn_fibonacci(int n){
	if(n==0){
        return 0;
    }else if(n==1){
        return 1;
    }else{
        return fn_fibonacci(n-1) + fn_fibonacci(n-2);
    }
}
```



ğŸ’¡ <u>**ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ Dynamic Programming ë°©ë²•ìœ¼ë¡œ í”¼ë³´ë‚˜ì¹˜ ì•Œê³ ë¦¬ì¦˜ì„ í’€ê²Œ ëœë‹¤ë©´,**</u>

â€‹	ë°°ì—´ ë˜ëŠ” HashMapì„ ìƒì„±í•˜ì—¬, ê°’ì„ ê°€ì§€ê³  ìˆëŠ”ë‹¤. (ë‹¤ì‹œ â™» í™œìš©í•œë‹¤.)

```java
// ë°°ì—´ì„ í†µí•´ ê°’ì„ ì €ì¥
int arr[100];
public static int fn_dp_arr_fibonacci(int n){
	if(n <= 1){		
        return n;
    }else if(n == 2){
        return 1;
    }else{
        if(arr[n] > 0){		//  ì´ë¯¸ ì—°ì‚°ì™„ë£Œí–ˆìœ¼ë¯€ë¡œ, ê°’ ë°˜í™˜
            return arr[n];
        }
        arr[n] = fn_dp_arr_fibonacci(n-1) + fn_dp_arr_fibonacci(n-2);
        return arr[n];
    }
}

// HashMapì„ í†µí•´ ê°’ì„ ì €ì¥
public static int fn_dp_map_fibonacci(int n, HashMap<Integer, Integer> dp){
	if(dp.contains(n)){		//  ì´ë¯¸ ì—°ì‚°ì™„ë£Œí–ˆìœ¼ë¯€ë¡œ, ê°’ ë°˜í™˜
        return dp.get(n);
    }else if(n == 0){
        return 0;
    }else if(n <= 2){
        return 1;
    }else{
        int value = fn_dp_map_fibonacci(n-1, dp) + fn_dp_map_fibonacci(n-2, dp);
        dp.put(n, value);
        return value;
    }
}
```



 ğŸ’¡**Tip**. ë™ì ê³„íšë²•ì„ í•´ê²°í•  ë•ŒëŠ” **ì´ë¯¸ ë‹µì„ ë±‰ì–´ë‚´ëŠ” í•¨ìˆ˜ë¥¼ ë‚´ê°€ ê°€ì§€ê³  ìˆë‹¤ê³  ê°€ì •**í•´ì•¼ ê·¸ ë‹¤ìŒ ìƒê°ì„ ì‰½ê²Œ ì „ê°œì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì°¸ê³  : https://blog.naver.com/oncoder-hs/221323255829







ì¶œì²˜ : https://m.blog.naver.com/oncoder-hs/220738696560

â€‹           https://developer-mac.tistory.com/77